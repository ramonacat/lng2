use crate::identifier::{Identifiers, Identifier};
use crate::ast;

grammar(identifiers: &mut Identifiers);

String: String = {
    r#""(\\"|[^"])*""# => String::from(&<>[1..<>.len() - 1])
}

Identifier: Identifier = {
    r"\p{ID_Start}\p{ID_Continue}*" => identifiers.intern(<>)
};

Expression: ast::Expression<()> = {
    <variable:Identifier> => ast::Expression {
        kind: ast::ExpressionKind::VariableAccess(variable),
        type_: ()
    },
    <target:Expression> "." <name:Identifier> => ast::Expression {
        kind: ast::ExpressionKind::FieldAccess(Box::new(target), name),
        type_: ()
    },
    <target:Expression> "(" ")" => ast::Expression {
        kind: ast::ExpressionKind::Call(Box::new(target)),
        type_: ()
    }
}

Statement: ast::Statement<()> = {
    <expression:Expression> ";" => ast::Statement::Expression(expression)
}

FunctionPrototype: ast::FunctionPrototype = {
    "fn" <name:Identifier> "(" ")" => ast::FunctionPrototype {
        name
    }
}

Function: ast::Function<(), ()> = {
    <prototype:FunctionPrototype> "{" <statements:(<Statement>)*> "}" => ast::Function { 
        kind: ast::FunctionKind::Implemented {
            prototype, 
            statements
        },
        type_: (),
    },
    // TODO real support for attributes
    "#" "[" "extern" "(" <external_name:String> ")" "]"
    <prototype:FunctionPrototype> ";" => ast::Function {
        kind: ast::FunctionKind::Extern {
            external_name,
            prototype
        },
        type_: ()
    }
}

Class: ast::Class<(), (), ()> = {
    "class" <name:Identifier> "{"
        <functions:(<Function>)*>
    "}" => ast::Class {
        name,
        functions,
        type_: ()
    }
}

Declaration: ast::Declaration<(), (), ()> = {
    <class:Class> => ast::Declaration::Class(class),
}

pub SourceFile: ast::SourceFile<(), (), ()> = { 
    <declarations:(<Declaration>)*> => ast::SourceFile {
        declarations
    }
}
